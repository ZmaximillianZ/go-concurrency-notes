package main

// Когда размер буфера больше 0, горутина не блокируется до тех пор,
// пока буфер не будет заполнен. Когда буфер заполнен, любые значения
// отправляемые через канал, добавляются к буферу, отбрасывая предыдущее
// значение, которое доступно для чтения (где горутина будет заблокирована).
// Но есть один подвох, операция чтения на буферизированном канале
// является жадной, таким образом, как только операция чтения началась,
// она не будет завершена до полного опустошения буфера. Это означает,
// что горутина будет считывать буфер канала без блокировки до тех пор,
// пока буфер не станет пустым.
// Syntax:
// c := make(chan Type, n)

import "fmt"

func bSquares(c chan int) {
	for i := 0; i <= 3; i++ {
		num := <-c
		fmt.Println(num * num)
	}
}

func main() {
	fmt.Println("main() started")
	c := make(chan int, 3)

	go bSquares(c)

	c <- 1 // len 1, cap 3
	c <- 2 // len 2, cap 3
	c <- 3 // len 3, cap 3
	c <- 4 // blocks here

	fmt.Println("main() stopped")
}

// Используя буферизованный канал и цикл for range, мы можем читать с
// закрытых каналов. Поскольку у закрытых каналов данные все еще живут
// в буфере, их можно считать:

func newMain() {
	c := make(chan int, 3)
	c <- 1
	c <- 2
	c <- 3
	close(c)

	// iteration terminates after receiving 3 values
	for elem := range c {
		fmt.Println(elem)
	}
}
